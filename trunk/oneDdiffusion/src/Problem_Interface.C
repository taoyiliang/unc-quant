//@HEADER
// ************************************************************************
// 
//            NOX: An Object-Oriented Nonlinear Solver Package
//                 Copyright (2002) Sandia Corporation
// 
//            LOCA: Library of Continuation Algorithms Package
//                 Copyright (2005) Sandia Corporation
// 
// Under terms of Contract DE-AC04-94AL85000, there is a non-exclusive
// license for use of this work by or on behalf of the U.S. Government.
// 
// This library is free software; you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as
// published by the Free Software Foundation; either version 2.1 of the
// License, or (at your option) any later version.
//  
// This library is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
// Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public
// License along with this library; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
// USA
// 
// Questions? Contact Roger Pawlowski (rppawlo@sandia.gov) or 
// Eric Phipps (etphipp@sandia.gov), Sandia National Laboratories.
// ************************************************************************
//  CVS Information
//  $Source$
//  $Author$
//  $Date$
//  $Revision$
// ************************************************************************
//@HEADER
                                                                                
// ----------   Includes   ----------
#include <iostream>
#include "Problem_Interface.h"

// ----------   User Defined Includes   ----------
#include "TwoDProblem.h"

//-----------------------------------------------------------------------------
//Problem_Interface::Problem_Interface(FiniteElementProblem& Problem) :
//  problem(Problem)
//{ }

Problem_Interface::Problem_Interface(TwoDProblem& Problem) :
  problem(Problem)
{ }

Problem_Interface::~Problem_Interface()
{ }

bool Problem_Interface::computeF(const Epetra_Vector& x, Epetra_Vector& FVec, FillType flag)
{
  ////
  // flag tells what is this nonlinear function evaluations for.
  // 0 : (Residual) The exact residual (F)is being computed.
  // 1 : (Jac)      The Jacobian  matrix is being estimated.
  // 2 : (Prec)     The preconditioner matrix is being estimated.
  // 3 : (FD_Res)   THe fill context is from a FD approximation
  // 4 : (MF_Res)   The fill context is Matrix-free approximation.
  // 5 : (MF_Jac)   The fill context is Matrix-free compute jacobian.
  // 6 : (User)     A user defined estimation is being performed.

  if( flag == 0) //exact residual
    return problem.evaluate(FILL_RES, &x, &FVec);
  else if( flag == 1 ) //jacobian
    return problem.evaluate(FILL_JAC, &x, &FVec);
  else if( flag == 2 ) //precon
    return problem.evaluate(FILL_PREC, &x, &FVec);
  else if( flag == 3 ) //fd-residual
    return problem.evaluate(FILL_FD_RES, &x, &FVec);
  else if( flag == 4 ) //mf-residual
    return problem.evaluate(FILL_MF_RES, &x, &FVec);
  else if( flag == 5 ) //mf-jacobian
    return problem.evaluate(FILL_MF_JAC, &x, &FVec);
  else if( flag == 6 ) //user-defined
    return problem.evaluate(FILL_USER, &x, &FVec);
  else
  {
    std::cout << "FillType is out of range : " << flag << std::endl;
    
    throw;
    
  }
  

}

bool Problem_Interface::computeJacobian(const Epetra_Vector& x,Epetra_Operator& Jac)
{
  std::cout << "Problem_Interface::computeJacobian"<<std::endl;
  
  Epetra_CrsMatrix* Jacobian = dynamic_cast<Epetra_CrsMatrix*>(&Jac);
  std::cout << "after dynamic_cast"<<std::endl;
  
  problem.createMatrix(&x,Jacobian);
  std::cout << "after matrix"<<std::endl;
  
  return true;
  
  if (Jacobian == NULL) {
    cout << "ERROR: Problem_Interface::computeJacobian() - The supplied"
	 << "Epetra_Operator is NOT an Epetra_RowMatrix!" << endl;
    throw;
  }

  return false;//problem.setupJacobianMatrix(&x, Jacobian);
}

bool Problem_Interface::computePreconditioner(const Epetra_Vector& x, Epetra_Operator& M, Teuchos::ParameterList* precParams)
{
  std::cout << "Problem_Interface::computePreconditioner "<<&M  <<std::endl;
  
  return problem.setupPrecOperator(&x,&M,precParams);
}
//-----------------------------------------------------------------------------

